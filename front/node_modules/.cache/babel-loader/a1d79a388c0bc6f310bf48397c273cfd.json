{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { createChunk, createNotFoundChunk } from '../Chunks';\nimport { createMapping, matchAgainstPathname } from '../Mapping';\nimport { createMatcherIterator } from '../Matcher';\nimport concat from '../utils/concat';\nexport function mount(paths) {\n  if (!paths) {\n    throw new Error(\"mount() must be supplied with a paths object.\");\n  }\n\n  var patterns = Object.keys(paths);\n  var nonWildcardPatterns = patterns.filter(function (pattern) {\n    return pattern !== '*';\n  });\n\n  if (process.env.NODE_ENV !== 'production') {\n    var invalidPaths = patterns.filter(function (pattern) {\n      return typeof paths[pattern] !== 'function';\n    });\n\n    if (invalidPaths.length > 0) {\n      throw new TypeError(\"The given paths: \" + invalidPaths.join(', ') + \" are invalid. \" + \"Their values should be matcher objects. See https://frontarm.com/navi/en/reference/matchers/\");\n    }\n  } // Wildcards in PatternMap objects are null (\\0) characters, so they'll\n  // always be sorted to the top. As such, by sorting the patterns, the\n  // most specific (i.e. without wildcard) will always be at the bottom.\n\n\n  var mappings = nonWildcardPatterns.map(function (pattern) {\n    return createMapping(pattern, paths[pattern]);\n  }).sort(function (x, y) {\n    return compareStrings(x.key, y.key);\n  });\n  return function (child) {\n    return function mountMatcherGenerator(request) {\n      var chunks, childIterators, childResults, childChunkLists, crawlRequests, crawler, crawling, crawlTuplesPromise, crawlTuples_1, error_1, i, mapping, childRequest, wildcardMatcher, i, childResult, foundChunks, i, childChunks;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            childResults = [];\n            childChunkLists = [];\n            crawlRequests = [];\n            crawler = request.crawler;\n            crawling = crawler && (request.path === '' || request.path === '/');\n            if (!crawling) return [3\n            /*break*/\n            , 5];\n            crawlTuplesPromise = createCrawlTuplesPromise(paths, crawler, request);\n            crawlTuplesPromise.then(function (x) {\n              crawlTuples_1 = x;\n            }, function (y) {\n              return error_1 = y;\n            });\n            _a.label = 1;\n\n          case 1:\n            return [4\n            /*yield*/\n            , [createChunk('busy', request, {\n              promise: crawlTuplesPromise\n            })]];\n\n          case 2:\n            _a.sent();\n\n            if (error_1) {\n              throw error_1;\n            }\n\n            _a.label = 3;\n\n          case 3:\n            if (!crawlTuples_1) return [3\n            /*break*/\n            , 1];\n            _a.label = 4;\n\n          case 4:\n            childIterators = crawlTuples_1.map(function (_a, i) {\n              var _b = __read(_a, 2),\n                  matcher = _b[0],\n                  crawlItem = _b[1];\n\n              var crawlRequest = __assign(__assign({}, request), {\n                mountpath: crawlItem.url.pathname,\n                url: '',\n                path: ''\n              });\n\n              crawlRequests[i] = crawlRequest;\n              return createMatcherIterator(matcher(child), crawlRequest, crawlRequest.mountpath);\n            });\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            // Start from the beginning and take the first result, as child mounts\n            // are sorted such that the first matching mount is the the most\n            // precise match (and we always want to use the most precise match).\n            for (i = mappings.length - 1; i >= 0; i--) {\n              mapping = mappings[i];\n              childRequest = matchAgainstPathname(request, mapping);\n\n              if (childRequest) {\n                childIterators = [createMatcherIterator(mapping.matcher(child), childRequest, mapping.pattern)]; // The first match is always the only match, as we don't allow\n                // for ambiguous patterns.\n\n                break;\n              }\n            } // If no matches are found, default to the wildcard pattern (if it\n            // exists)\n\n\n            if (!childIterators) {\n              wildcardMatcher = paths['*'];\n\n              if (wildcardMatcher) {\n                childIterators = [createMatcherIterator(wildcardMatcher(child), request, '*')];\n              }\n            }\n\n            _a.label = 6;\n\n          case 6:\n            if (childIterators) {\n              for (i = 0; i < childIterators.length; i++) {\n                childResult = childResults[i];\n\n                if (!childResult || !childResult.done) {\n                  childResult = childResults[i] = childIterators[i].next();\n                }\n\n                if (childResult && !childResult.done) {\n                  childChunkLists[i] = childResult.value;\n                }\n              }\n            }\n\n            chunks = [createChunk('mount', request, {\n              patterns: patterns\n            })];\n            foundChunks = false;\n\n            for (i = 0; i < childResults.length; i++) {\n              childChunks = childChunkLists[i];\n\n              if (childChunks) {\n                foundChunks = true;\n\n                if (crawling && !childChunks.some(isMountChunk)) {\n                  chunks = chunks.concat(createChunk('crawl', crawlRequests[i]));\n                }\n\n                chunks = chunks.concat(childChunks);\n              }\n            }\n\n            if (!crawler && !foundChunks) {\n              chunks.push(createNotFoundChunk(request));\n            }\n\n            return [4\n            /*yield*/\n            , chunks];\n\n          case 7:\n            _a.sent();\n\n            _a.label = 8;\n\n          case 8:\n            if (chunks.filter(isBusy).length) return [3\n            /*break*/\n            , 6];\n            _a.label = 9;\n\n          case 9:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    };\n  };\n}\n\nfunction compareStrings(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction isBusy(chunk) {\n  return chunk.type === 'busy';\n}\n\nfunction createCrawlTuplesPromise(paths, crawler, parentRequest) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _a = concat;\n          return [4\n          /*yield*/\n          , Promise.all(Object.entries(paths).map(function (_a) {\n            var _b = __read(_a, 2),\n                pattern = _b[0],\n                matcher = _b[1];\n\n            return crawler(pattern === '*' ? '' : pattern, parentRequest).then(createTuplesWith(matcher));\n          }))];\n\n        case 1:\n          return [2\n          /*return*/\n          , _a.apply(void 0, [_b.sent()])];\n      }\n    });\n  });\n}\n\nfunction createTuplesWith(x) {\n  return function (ys) {\n    return ys.map(function (y) {\n      return [x, y];\n    });\n  };\n}\n\nfunction isMountChunk(chunk) {\n  return chunk.type === 'mount';\n}","map":{"version":3,"sources":["../../../src/matchers/mount.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { createChunk, createNotFoundChunk } from '../Chunks';\nimport { createMapping, matchAgainstPathname } from '../Mapping';\nimport { createMatcherIterator } from '../Matcher';\nimport concat from '../utils/concat';\nexport function mount(paths) {\n    if (!paths) {\n        throw new Error(\"mount() must be supplied with a paths object.\");\n    }\n    var patterns = Object.keys(paths);\n    var nonWildcardPatterns = patterns.filter(function (pattern) { return pattern !== '*'; });\n    if (process.env.NODE_ENV !== 'production') {\n        var invalidPaths = patterns.filter(function (pattern) { return typeof paths[pattern] !== 'function'; });\n        if (invalidPaths.length > 0) {\n            throw new TypeError(\"The given paths: \" + invalidPaths.join(', ') + \" are invalid. \" +\n                \"Their values should be matcher objects. See https://frontarm.com/navi/en/reference/matchers/\");\n        }\n    }\n    // Wildcards in PatternMap objects are null (\\0) characters, so they'll\n    // always be sorted to the top. As such, by sorting the patterns, the\n    // most specific (i.e. without wildcard) will always be at the bottom.\n    var mappings = nonWildcardPatterns\n        .map(function (pattern) { return createMapping(pattern, paths[pattern]); })\n        .sort(function (x, y) { return compareStrings(x.key, y.key); });\n    return function (child) {\n        return function mountMatcherGenerator(request) {\n            var chunks, childIterators, childResults, childChunkLists, crawlRequests, crawler, crawling, crawlTuplesPromise, crawlTuples_1, error_1, i, mapping, childRequest, wildcardMatcher, i, childResult, foundChunks, i, childChunks;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        childResults = [];\n                        childChunkLists = [];\n                        crawlRequests = [];\n                        crawler = request.crawler;\n                        crawling = crawler && (request.path === '' || request.path === '/');\n                        if (!crawling) return [3 /*break*/, 5];\n                        crawlTuplesPromise = createCrawlTuplesPromise(paths, crawler, request);\n                        crawlTuplesPromise.then(function (x) { crawlTuples_1 = x; }, function (y) { return error_1 = y; });\n                        _a.label = 1;\n                    case 1: return [4 /*yield*/, [createChunk('busy', request, { promise: crawlTuplesPromise })]];\n                    case 2:\n                        _a.sent();\n                        if (error_1) {\n                            throw error_1;\n                        }\n                        _a.label = 3;\n                    case 3:\n                        if (!crawlTuples_1) return [3 /*break*/, 1];\n                        _a.label = 4;\n                    case 4:\n                        childIterators = crawlTuples_1.map(function (_a, i) {\n                            var _b = __read(_a, 2), matcher = _b[0], crawlItem = _b[1];\n                            var crawlRequest = __assign(__assign({}, request), { mountpath: crawlItem.url.pathname, url: '', path: '' });\n                            crawlRequests[i] = crawlRequest;\n                            return createMatcherIterator(matcher(child), crawlRequest, crawlRequest.mountpath);\n                        });\n                        return [3 /*break*/, 6];\n                    case 5:\n                        // Start from the beginning and take the first result, as child mounts\n                        // are sorted such that the first matching mount is the the most\n                        // precise match (and we always want to use the most precise match).\n                        for (i = mappings.length - 1; i >= 0; i--) {\n                            mapping = mappings[i];\n                            childRequest = matchAgainstPathname(request, mapping);\n                            if (childRequest) {\n                                childIterators = [createMatcherIterator(mapping.matcher(child), childRequest, mapping.pattern)];\n                                // The first match is always the only match, as we don't allow\n                                // for ambiguous patterns.\n                                break;\n                            }\n                        }\n                        // If no matches are found, default to the wildcard pattern (if it\n                        // exists)\n                        if (!childIterators) {\n                            wildcardMatcher = paths['*'];\n                            if (wildcardMatcher) {\n                                childIterators = [createMatcherIterator(wildcardMatcher(child), request, '*')];\n                            }\n                        }\n                        _a.label = 6;\n                    case 6:\n                        if (childIterators) {\n                            for (i = 0; i < childIterators.length; i++) {\n                                childResult = childResults[i];\n                                if (!childResult || !childResult.done) {\n                                    childResult = childResults[i] = childIterators[i].next();\n                                }\n                                if (childResult && !childResult.done) {\n                                    childChunkLists[i] = childResult.value;\n                                }\n                            }\n                        }\n                        chunks = [createChunk('mount', request, { patterns: patterns })];\n                        foundChunks = false;\n                        for (i = 0; i < childResults.length; i++) {\n                            childChunks = childChunkLists[i];\n                            if (childChunks) {\n                                foundChunks = true;\n                                if (crawling && !childChunks.some(isMountChunk)) {\n                                    chunks = chunks.concat(createChunk('crawl', crawlRequests[i]));\n                                }\n                                chunks = chunks.concat(childChunks);\n                            }\n                        }\n                        if (!crawler && !foundChunks) {\n                            chunks.push(createNotFoundChunk(request));\n                        }\n                        return [4 /*yield*/, chunks];\n                    case 7:\n                        _a.sent();\n                        _a.label = 8;\n                    case 8:\n                        if (chunks.filter(isBusy).length) return [3 /*break*/, 6];\n                        _a.label = 9;\n                    case 9: return [2 /*return*/];\n                }\n            });\n        };\n    };\n}\nfunction compareStrings(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\nfunction isBusy(chunk) {\n    return chunk.type === 'busy';\n}\nfunction createCrawlTuplesPromise(paths, crawler, parentRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = concat;\n                    return [4 /*yield*/, Promise.all(Object.entries(paths).map(function (_a) {\n                            var _b = __read(_a, 2), pattern = _b[0], matcher = _b[1];\n                            return crawler(pattern === '*' ? '' : pattern, parentRequest).then(createTuplesWith(matcher));\n                        }))];\n                case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n            }\n        });\n    });\n}\nfunction createTuplesWith(x) {\n    return function (ys) { return ys.map(function (y) { return [x, y]; }); };\n}\nfunction isMountChunk(chunk) {\n    return chunk.type === 'mount';\n}\n//# sourceMappingURL=mount.js.map"]},"metadata":{},"sourceType":"module"}