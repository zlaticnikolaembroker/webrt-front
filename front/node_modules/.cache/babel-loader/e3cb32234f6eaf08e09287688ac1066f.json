{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport * as React from 'react';\nimport { HashScrollContext, scrollToHash } from './HashScroll';\nimport { NaviContext } from './NaviContext';\nimport { ViewHeadRendererContext } from './ViewHeadRendererContext';\n\nfunction defaultUseViewChunkPredicate(chunk) {\n  return chunk.type === 'view';\n}\n\nexport function useViewElement(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var result = useView(options);\n  return result && result.element;\n}\nexport function useView(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.disableScrolling,\n      disableScrolling = _c === void 0 ? false : _c,\n      hashScrollBehavior = _b.hashScrollBehavior,\n      renderHead = _b.renderHead,\n      _d = _b.where,\n      where = _d === void 0 ? defaultUseViewChunkPredicate : _d;\n\n  var hashScrollBehaviorFromContext = React.useContext(HashScrollContext);\n  var renderHeadFromContext = React.useContext(ViewHeadRendererContext);\n  var context = React.useContext(NaviContext);\n\n  if (hashScrollBehavior === undefined) {\n    hashScrollBehavior = hashScrollBehaviorFromContext;\n  }\n\n  if (renderHead === undefined && renderHeadFromContext) {\n    renderHead = renderHeadFromContext;\n  }\n\n  var route = context.steadyRoute || context.busyRoute;\n\n  if (!route) {\n    throw new Error('react-navi: A <View> component cannot be rendered outside of a <Router> or <NaviProvider> component.');\n  }\n\n  var unconsumedChunks = context.unconsumedSteadyRouteChunks || route.chunks;\n  var index = unconsumedChunks.findIndex(where);\n  var view = index !== -1 && unconsumedChunks[index].view; // Find any other chunks that come before this chunk, or after this one if\n  // this is the final view chunk.\n  //\n  // Don't treat this as the final chunk is there is an error, as that means\n  // we don't know whether this is really meant to be the final chunk, and we\n  // don't want to throw an error before rendering whatever views we can.\n\n  var final = index === -1 || !unconsumedChunks.slice(index + 1).find(where) && route.type !== 'error';\n  var chunks = React.useMemo(function () {\n    return final ? unconsumedChunks : unconsumedChunks.slice(0, index + 1);\n  }, [final, unconsumedChunks, index]); // Look for an error amongst any route chunks that haven't already been used\n  // by a `useView()` and throw it.\n\n  var errorChunk = chunks.find(function (chunk) {\n    return chunk.type === 'error';\n  });\n\n  if (errorChunk) {\n    throw errorChunk.error || new Error('Unknown routing error');\n  } // If there's no steady route, then we'll need to wait until a steady\n  // route becomes available using Supsense.\n\n\n  if (!view && !context.steadyRoute) {\n    throw context.navigation.getRoute();\n  }\n\n  var childContext = React.useMemo(function () {\n    return __assign(__assign({}, context), {\n      unconsumedSteadyRouteChunks: final ? [] : unconsumedChunks.slice(index + 1)\n    });\n  }, [context, unconsumedChunks, index]);\n  var connect = React.useCallback(function (children) {\n    return React.createElement(NaviContext.Provider, {\n      value: childContext\n    }, // Clone the content to force a re-render even if content hasn't\n    // changed, as Provider is a PureComponent.\n    React.isValidElement(children) ? React.cloneElement(children) : children);\n  }, [childContext]);\n  var content = React.useMemo(function () {\n    return typeof view === 'function' ? React.createElement(view, {\n      route: context.steadyRoute\n    }) : view || null;\n  }, [view, context.steadyRoute]);\n  var head = React.useMemo(function () {\n    return !renderHead ? null : renderHead(chunks);\n  }, [renderHead, chunks]); // Scroll to hash or top of page if appropriate.\n\n  var lastRouteRef = React.useRef();\n  React.useEffect(function () {\n    var nextRoute = route;\n    var prevRoute = lastRouteRef.current;\n    lastRouteRef.current = route;\n\n    if (final && route && unconsumedChunks.length !== 0) {\n      if (nextRoute && nextRoute.type !== 'busy') {\n        if (prevRoute && nextRoute.url.pathname === prevRoute.url.pathname && nextRoute.url.search === prevRoute.url.search && nextRoute.url.hash === prevRoute.url.hash) {\n          return;\n        }\n\n        if (!disableScrolling && (!prevRoute || !prevRoute.url || prevRoute.url.hash !== nextRoute.url.hash || prevRoute.url.pathname !== nextRoute.url.pathname)) {\n          scrollToHash(nextRoute.url.hash, prevRoute && prevRoute.url && prevRoute.url.pathname === nextRoute.url.pathname ? hashScrollBehavior : 'auto');\n        }\n      }\n    }\n  }, [route]);\n  var result = React.useMemo(function () {\n    return {\n      chunks: chunks,\n      connect: connect,\n      content: content,\n      element: connect(React.createElement(React.Fragment, null, head, content)),\n      final: final,\n      head: head\n    };\n  }, [chunks, connect, content, final, head]);\n  return unconsumedChunks.length === 0 ? null : result;\n}\nexport var View = function View(_a) {\n  var disableScrolling = _a.disableScrolling,\n      hashScrollBehavior = _a.hashScrollBehavior,\n      renderHead = _a.renderHead,\n      where = _a.where;\n  var result = useView({\n    disableScrolling: disableScrolling,\n    hashScrollBehavior: hashScrollBehavior,\n    renderHead: renderHead,\n    where: where\n  });\n\n  if (!result) {\n    throw new Error('A Navi <View> was not able to find a view to render.');\n  }\n\n  return result.element;\n};","map":{"version":3,"sources":["../../src/View.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport * as React from 'react';\nimport { HashScrollContext, scrollToHash, } from './HashScroll';\nimport { NaviContext } from './NaviContext';\nimport { ViewHeadRendererContext } from './ViewHeadRendererContext';\nfunction defaultUseViewChunkPredicate(chunk) {\n    return chunk.type === 'view';\n}\nexport function useViewElement(options) {\n    if (options === void 0) { options = {}; }\n    var result = useView(options);\n    return result && result.element;\n}\nexport function useView(_a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.disableScrolling, disableScrolling = _c === void 0 ? false : _c, hashScrollBehavior = _b.hashScrollBehavior, renderHead = _b.renderHead, _d = _b.where, where = _d === void 0 ? defaultUseViewChunkPredicate : _d;\n    var hashScrollBehaviorFromContext = React.useContext(HashScrollContext);\n    var renderHeadFromContext = React.useContext(ViewHeadRendererContext);\n    var context = React.useContext(NaviContext);\n    if (hashScrollBehavior === undefined) {\n        hashScrollBehavior = hashScrollBehaviorFromContext;\n    }\n    if (renderHead === undefined && renderHeadFromContext) {\n        renderHead = renderHeadFromContext;\n    }\n    var route = context.steadyRoute || context.busyRoute;\n    if (!route) {\n        throw new Error('react-navi: A <View> component cannot be rendered outside of a <Router> or <NaviProvider> component.');\n    }\n    var unconsumedChunks = context.unconsumedSteadyRouteChunks || route.chunks;\n    var index = unconsumedChunks.findIndex(where);\n    var view = index !== -1 && unconsumedChunks[index].view;\n    // Find any other chunks that come before this chunk, or after this one if\n    // this is the final view chunk.\n    //\n    // Don't treat this as the final chunk is there is an error, as that means\n    // we don't know whether this is really meant to be the final chunk, and we\n    // don't want to throw an error before rendering whatever views we can.\n    var final = index === -1 ||\n        (!unconsumedChunks.slice(index + 1).find(where) && route.type !== 'error');\n    var chunks = React.useMemo(function () { return (final ? unconsumedChunks : unconsumedChunks.slice(0, index + 1)); }, [final, unconsumedChunks, index]);\n    // Look for an error amongst any route chunks that haven't already been used\n    // by a `useView()` and throw it.\n    var errorChunk = chunks.find(function (chunk) { return chunk.type === 'error'; });\n    if (errorChunk) {\n        throw errorChunk.error || new Error('Unknown routing error');\n    }\n    // If there's no steady route, then we'll need to wait until a steady\n    // route becomes available using Supsense.\n    if (!view && !context.steadyRoute) {\n        throw context.navigation.getRoute();\n    }\n    var childContext = React.useMemo(function () { return (__assign(__assign({}, context), { unconsumedSteadyRouteChunks: final\n            ? []\n            : unconsumedChunks.slice(index + 1) })); }, [context, unconsumedChunks, index]);\n    var connect = React.useCallback(function (children) {\n        return (React.createElement(NaviContext.Provider, { value: childContext }, // Clone the content to force a re-render even if content hasn't\n        // changed, as Provider is a PureComponent.\n        React.isValidElement(children)\n            ? React.cloneElement(children)\n            : children));\n    }, [childContext]);\n    var content = React.useMemo(function () {\n        return typeof view === 'function'\n            ? React.createElement(view, {\n                route: context.steadyRoute,\n            })\n            : view || null;\n    }, [view, context.steadyRoute]);\n    var head = React.useMemo(function () { return (!renderHead ? null : renderHead(chunks)); }, [\n        renderHead,\n        chunks,\n    ]);\n    // Scroll to hash or top of page if appropriate.\n    var lastRouteRef = React.useRef();\n    React.useEffect(function () {\n        var nextRoute = route;\n        var prevRoute = lastRouteRef.current;\n        lastRouteRef.current = route;\n        if (final && route && unconsumedChunks.length !== 0) {\n            if (nextRoute && nextRoute.type !== 'busy') {\n                if (prevRoute &&\n                    nextRoute.url.pathname === prevRoute.url.pathname &&\n                    nextRoute.url.search === prevRoute.url.search &&\n                    nextRoute.url.hash === prevRoute.url.hash) {\n                    return;\n                }\n                if (!disableScrolling &&\n                    (!prevRoute ||\n                        !prevRoute.url ||\n                        prevRoute.url.hash !== nextRoute.url.hash ||\n                        prevRoute.url.pathname !== nextRoute.url.pathname)) {\n                    scrollToHash(nextRoute.url.hash, prevRoute &&\n                        prevRoute.url &&\n                        prevRoute.url.pathname === nextRoute.url.pathname\n                        ? hashScrollBehavior\n                        : 'auto');\n                }\n            }\n        }\n    }, [route]);\n    var result = React.useMemo(function () { return ({\n        chunks: chunks,\n        connect: connect,\n        content: content,\n        element: connect(React.createElement(React.Fragment, null,\n            head,\n            content)),\n        final: final,\n        head: head,\n    }); }, [chunks, connect, content, final, head]);\n    return unconsumedChunks.length === 0 ? null : result;\n}\nexport var View = function View(_a) {\n    var disableScrolling = _a.disableScrolling, hashScrollBehavior = _a.hashScrollBehavior, renderHead = _a.renderHead, where = _a.where;\n    var result = useView({\n        disableScrolling: disableScrolling,\n        hashScrollBehavior: hashScrollBehavior,\n        renderHead: renderHead,\n        where: where,\n    });\n    if (!result) {\n        throw new Error('A Navi <View> was not able to find a view to render.');\n    }\n    return result.element;\n};\n//# sourceMappingURL=View.js.map"]},"metadata":{},"sourceType":"module"}