{"ast":null,"code":"var __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nimport { joinPaths } from './URLTools';\nimport { NotFoundError } from './Errors';\nimport { createChunk } from './Chunks';\nexport default function resolveChunks(maybeResolvable, request, createChunks) {\n  var resolvable, maybeValue, result, promise, unwrappedPromise, busyChunks, error;\n  return __generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        resolvable = typeof maybeResolvable === 'function' ? maybeResolvable : function () {\n          return maybeResolvable;\n        };\n\n        try {\n          maybeValue = resolvable(request, request.context);\n        } catch (e) {\n          maybeValue = Promise.reject(e);\n        }\n\n        if (!!isPromiseLike(maybeValue)) return [3\n        /*break*/\n        , 1];\n        result = createChunks(maybeValue);\n        return [3\n        /*break*/\n        , 7];\n\n      case 1:\n        promise = maybeValue.then(extractDefault);\n        unwrappedPromise = unwrapPromise(promise);\n        busyChunks = [createChunk('busy', request, {\n          promise: promise\n        })];\n        _a.label = 2;\n\n      case 2:\n        if (!!unwrappedPromise.outcome) return [3\n        /*break*/\n        , 4];\n        return [4\n        /*yield*/\n        , busyChunks];\n\n      case 3:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 2];\n\n      case 4:\n        if (!(unwrappedPromise.outcome === 'rejected')) return [3\n        /*break*/\n        , 6];\n        error = unwrappedPromise.error;\n\n        if (error instanceof NotFoundError && !error.pathname) {\n          error.pathname = joinPaths(request.mountpath, request.path);\n        }\n\n        return [4\n        /*yield*/\n        , [createChunk('error', request, {\n          error: error\n        })]];\n\n      case 5:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 7];\n\n      case 6:\n        result = createChunks(unwrappedPromise.value);\n        _a.label = 7;\n\n      case 7:\n        if (!result) return [3\n        /*break*/\n        , 11];\n        if (!Array.isArray(result)) return [3\n        /*break*/\n        , 9];\n        return [4\n        /*yield*/\n        , result.length ? result : []];\n\n      case 8:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 11];\n\n      case 9:\n        return [5\n        /*yield**/\n        , __values(result)];\n\n      case 10:\n        _a.sent();\n\n        _a.label = 11;\n\n      case 11:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n\nfunction unwrapPromise(promise) {\n  var result = {};\n  promise.then(function (value) {\n    result.value = value;\n    result.outcome = 'resolved';\n  }, function (error) {\n    result.error = error;\n    result.outcome = 'rejected';\n  });\n  return result;\n} // Not all promise libraries use the ES6 `Promise` constructor,\n// so there isn't a better way to check if it's a promise :-(\n\n\nexport function isPromiseLike(x) {\n  return !!x && !!x['then'];\n}\nexport function extractDefault(value) {\n  if (hasDefault(value)) {\n    return value.default;\n  } else {\n    return value;\n  }\n}\n\nfunction hasDefault(value) {\n  return value && typeof value === 'object' && 'default' in value;\n}","map":{"version":3,"sources":["../../src/Resolvable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { joinPaths } from './URLTools';\nimport { NotFoundError } from './Errors';\nimport { createChunk } from './Chunks';\nexport default function resolveChunks(maybeResolvable, request, createChunks) {\n    var resolvable, maybeValue, result, promise, unwrappedPromise, busyChunks, error;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                resolvable = typeof maybeResolvable === 'function'\n                    ? maybeResolvable\n                    : function () { return maybeResolvable; };\n                try {\n                    maybeValue = resolvable(request, request.context);\n                }\n                catch (e) {\n                    maybeValue = Promise.reject(e);\n                }\n                if (!!isPromiseLike(maybeValue)) return [3 /*break*/, 1];\n                result = createChunks(maybeValue);\n                return [3 /*break*/, 7];\n            case 1:\n                promise = maybeValue.then(extractDefault);\n                unwrappedPromise = unwrapPromise(promise);\n                busyChunks = [createChunk('busy', request, { promise: promise })];\n                _a.label = 2;\n            case 2:\n                if (!!unwrappedPromise.outcome) return [3 /*break*/, 4];\n                return [4 /*yield*/, busyChunks];\n            case 3:\n                _a.sent();\n                return [3 /*break*/, 2];\n            case 4:\n                if (!(unwrappedPromise.outcome === 'rejected')) return [3 /*break*/, 6];\n                error = unwrappedPromise.error;\n                if (error instanceof NotFoundError && !error.pathname) {\n                    error.pathname = joinPaths(request.mountpath, request.path);\n                }\n                return [4 /*yield*/, [createChunk('error', request, { error: error })]];\n            case 5:\n                _a.sent();\n                return [3 /*break*/, 7];\n            case 6:\n                result = createChunks(unwrappedPromise.value);\n                _a.label = 7;\n            case 7:\n                if (!result) return [3 /*break*/, 11];\n                if (!Array.isArray(result)) return [3 /*break*/, 9];\n                return [4 /*yield*/, result.length ? result : []];\n            case 8:\n                _a.sent();\n                return [3 /*break*/, 11];\n            case 9: return [5 /*yield**/, __values(result)];\n            case 10:\n                _a.sent();\n                _a.label = 11;\n            case 11: return [2 /*return*/];\n        }\n    });\n}\nfunction unwrapPromise(promise) {\n    var result = {};\n    promise.then(function (value) {\n        result.value = value;\n        result.outcome = 'resolved';\n    }, function (error) {\n        result.error = error;\n        result.outcome = 'rejected';\n    });\n    return result;\n}\n// Not all promise libraries use the ES6 `Promise` constructor,\n// so there isn't a better way to check if it's a promise :-(\nexport function isPromiseLike(x) {\n    return !!x && !!x['then'];\n}\nexport function extractDefault(value) {\n    if (hasDefault(value)) {\n        return value.default;\n    }\n    else {\n        return value;\n    }\n}\nfunction hasDefault(value) {\n    return value && typeof value === 'object' && 'default' in value;\n}\n//# sourceMappingURL=Resolvable.js.map"]},"metadata":{},"sourceType":"module"}