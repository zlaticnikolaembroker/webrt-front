{"ast":null,"code":"import { createRootMapping, matchAgainstPathname } from './Mapping';\nimport { ChunkListObservable } from './ChunkListObservable';\nimport { ChunksMapObservable } from './ChunksMapObservable';\nimport { routeReducer } from './Route';\nimport { createPromiseFromObservable } from './Observable';\nimport { createURLDescriptor } from './URLTools';\nimport { OutOfRootError } from './Errors';\nexport function createRouter(options) {\n  return new Router(options);\n}\n\nvar Router =\n/** @class */\nfunction () {\n  function Router(options) {\n    this.context = options.context || {};\n    this.matcherGenerator = options.routes();\n    var basename = options.basename;\n\n    if (basename && basename.slice(-1) === '/') {\n      basename = basename.slice(0, -1);\n    }\n\n    this.rootMapping = createRootMapping(options.routes, basename);\n  } // Please don't document this API. It should only be used through\n  // \"createBrowserNavigation()\" or \"createMemoryNavigation()\"\n\n\n  Router.prototype.setContext = function (context) {\n    this.context = context || {};\n  };\n\n  Router.prototype.createObservable = function (url, options) {\n    var request = {\n      body: options.body,\n      context: this.context,\n      headers: options.headers || {},\n      method: options.method || 'GET',\n      hostname: url.hostname,\n      hash: url.hash,\n      mountpath: '/',\n      params: url.query,\n      query: url.query,\n      search: url.search,\n      url: url.pathname + url.search,\n      originalUrl: url.href,\n      path: url.pathname,\n      crawler: options.crawler,\n      state: options.state || {}\n    };\n    var matchRequest = matchAgainstPathname(request, this.rootMapping);\n\n    if (matchRequest) {\n      return new ChunkListObservable(url, matchRequest, this.matcherGenerator);\n    }\n  };\n\n  Router.prototype.createMapObservable = function (urlOrDescriptor, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new ChunksMapObservable(createURLDescriptor(urlOrDescriptor), this.context, this.matcherGenerator, this.rootMapping, this, options);\n  };\n\n  Router.prototype.resolve = function (urls, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var urlDescriptors;\n\n    if (Array.isArray(urls)) {\n      urlDescriptors = urls.map(function (url) {\n        return createURLDescriptor(url);\n      });\n    } else if (typeof urls === 'string') {\n      urlDescriptors = [createURLDescriptor(urls)];\n    } else if (urls.url) {\n      options = urls;\n      urlDescriptors = [createURLDescriptor(options.url)];\n    } else if (options) {\n      urlDescriptors = [createURLDescriptor(urls)];\n    } else {\n      throw new Error(\"You must specify a URL for router.resolve().\");\n    }\n\n    if (!urlDescriptors.length) {\n      return Promise.resolve([]);\n    }\n\n    var promises = urlDescriptors.map(function (url) {\n      return _this.getPageRoutePromise(url, options);\n    });\n    return !Array.isArray(urls) ? promises[0] : Promise.all(promises);\n  };\n\n  Router.prototype.resolveSiteMap = function (urlOrDescriptor, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return createPromiseFromObservable(this.createMapObservable(urlOrDescriptor, options)).then(function (chunksMap) {\n      var routeMap = {};\n      var redirectMap = {};\n      var urls = Object.keys(chunksMap);\n\n      for (var i = 0; i < urls.length; i++) {\n        var url = urls[i];\n        var chunks = chunksMap[url];\n        var lastChunk = chunks[chunks.length - 1];\n\n        if (lastChunk.type === 'redirect') {\n          redirectMap[url] = lastChunk.to;\n          continue;\n        } else {\n          routeMap[url] = [{\n            type: 'url',\n            url: createURLDescriptor(url)\n          }].concat(chunks).reduce(routeReducer, undefined);\n        }\n      }\n\n      return {\n        routes: routeMap,\n        redirects: redirectMap\n      };\n    });\n  };\n\n  Router.prototype.resolveRouteMap = function (urlOrDescriptor, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return this.resolveSiteMap(urlOrDescriptor, options).then(function (siteMap) {\n      return siteMap.routes;\n    });\n  };\n\n  Router.prototype.getPageRoutePromise = function (url, options) {\n    var _this = this;\n\n    var observable = this.createObservable(url, options);\n\n    if (!observable) {\n      return Promise.reject(new OutOfRootError(url));\n    }\n\n    return createPromiseFromObservable(observable).then(function (chunks) {\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i];\n\n        if (chunk.type === 'busy') {\n          break;\n        }\n\n        if (chunk.type === 'redirect' && options.followRedirects) {\n          return _this.getPageRoutePromise(createURLDescriptor(chunk.to), options);\n        }\n\n        if (chunk.type === 'error') {\n          throw chunk.error;\n        }\n      }\n\n      return [{\n        type: 'url',\n        url: createURLDescriptor(url)\n      }].concat(chunks).reduce(routeReducer, undefined);\n    });\n  };\n\n  return Router;\n}();\n\nexport { Router };","map":{"version":3,"sources":["../../src/Router.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { createRootMapping, matchAgainstPathname } from './Mapping';\nimport { ChunkListObservable } from './ChunkListObservable';\nimport { ChunksMapObservable } from './ChunksMapObservable';\nimport { routeReducer } from './Route';\nimport { createPromiseFromObservable } from './Observable';\nimport { createURLDescriptor } from './URLTools';\nimport { OutOfRootError } from './Errors';\nexport function createRouter(options) {\n    return new Router(options);\n}\nvar Router = /** @class */ (function () {\n    function Router(options) {\n        this.context = options.context || {};\n        this.matcherGenerator = options.routes();\n        var basename = options.basename;\n        if (basename && basename.slice(-1) === '/') {\n            basename = basename.slice(0, -1);\n        }\n        this.rootMapping = createRootMapping(options.routes, basename);\n    }\n    // Please don't document this API. It should only be used through\n    // \"createBrowserNavigation()\" or \"createMemoryNavigation()\"\n    Router.prototype.setContext = function (context) {\n        this.context = context || {};\n    };\n    Router.prototype.createObservable = function (url, options) {\n        var request = {\n            body: options.body,\n            context: this.context,\n            headers: options.headers || {},\n            method: options.method || 'GET',\n            hostname: url.hostname,\n            hash: url.hash,\n            mountpath: '/',\n            params: url.query,\n            query: url.query,\n            search: url.search,\n            url: url.pathname + url.search,\n            originalUrl: url.href,\n            path: url.pathname,\n            crawler: options.crawler,\n            state: options.state || {},\n        };\n        var matchRequest = matchAgainstPathname(request, this.rootMapping);\n        if (matchRequest) {\n            return new ChunkListObservable(url, matchRequest, this.matcherGenerator);\n        }\n    };\n    Router.prototype.createMapObservable = function (urlOrDescriptor, options) {\n        if (options === void 0) { options = {}; }\n        return new ChunksMapObservable(createURLDescriptor(urlOrDescriptor), this.context, this.matcherGenerator, this.rootMapping, this, options);\n    };\n    Router.prototype.resolve = function (urls, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        var urlDescriptors;\n        if (Array.isArray(urls)) {\n            urlDescriptors = urls.map(function (url) { return createURLDescriptor(url); });\n        }\n        else if (typeof urls === 'string') {\n            urlDescriptors = [createURLDescriptor(urls)];\n        }\n        else if (urls.url) {\n            options = urls;\n            urlDescriptors = [createURLDescriptor(options.url)];\n        }\n        else if (options) {\n            urlDescriptors = [createURLDescriptor(urls)];\n        }\n        else {\n            throw new Error(\"You must specify a URL for router.resolve().\");\n        }\n        if (!urlDescriptors.length) {\n            return Promise.resolve([]);\n        }\n        var promises = urlDescriptors.map(function (url) {\n            return _this.getPageRoutePromise(url, options);\n        });\n        return !Array.isArray(urls) ? promises[0] : Promise.all(promises);\n    };\n    Router.prototype.resolveSiteMap = function (urlOrDescriptor, options) {\n        if (options === void 0) { options = {}; }\n        return createPromiseFromObservable(this.createMapObservable(urlOrDescriptor, options)).then(function (chunksMap) {\n            var routeMap = {};\n            var redirectMap = {};\n            var urls = Object.keys(chunksMap);\n            for (var i = 0; i < urls.length; i++) {\n                var url = urls[i];\n                var chunks = chunksMap[url];\n                var lastChunk = chunks[chunks.length - 1];\n                if (lastChunk.type === 'redirect') {\n                    redirectMap[url] = lastChunk.to;\n                    continue;\n                }\n                else {\n                    routeMap[url] = [{ type: 'url', url: createURLDescriptor(url) }]\n                        .concat(chunks)\n                        .reduce(routeReducer, undefined);\n                }\n            }\n            return {\n                routes: routeMap,\n                redirects: redirectMap,\n            };\n        });\n    };\n    Router.prototype.resolveRouteMap = function (urlOrDescriptor, options) {\n        if (options === void 0) { options = {}; }\n        return this.resolveSiteMap(urlOrDescriptor, options).then(function (siteMap) { return siteMap.routes; });\n    };\n    Router.prototype.getPageRoutePromise = function (url, options) {\n        var _this = this;\n        var observable = this.createObservable(url, options);\n        if (!observable) {\n            return Promise.reject(new OutOfRootError(url));\n        }\n        return createPromiseFromObservable(observable).then(function (chunks) {\n            for (var i = 0; i < chunks.length; i++) {\n                var chunk = chunks[i];\n                if (chunk.type === 'busy') {\n                    break;\n                }\n                if (chunk.type === 'redirect' && options.followRedirects) {\n                    return _this.getPageRoutePromise(createURLDescriptor(chunk.to), options);\n                }\n                if (chunk.type === 'error') {\n                    throw chunk.error;\n                }\n            }\n            return [{ type: 'url', url: createURLDescriptor(url) }]\n                .concat(chunks)\n                .reduce(routeReducer, undefined);\n        });\n    };\n    return Router;\n}());\nexport { Router };\n//# sourceMappingURL=Router.js.map"]},"metadata":{},"sourceType":"module"}