{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { createURLDescriptor, joinPaths, modifyTrailingSlash } from './URLTools';\nimport { SimpleSubscription, createOrPassthroughObserver } from './Observable';\nimport { matchAgainstPathname } from './Mapping';\n\nvar ChunksMapObservable =\n/** @class */\nfunction () {\n  function ChunksMapObservable(url, rootContext, matcherGeneratorClass, rootMapping, router, options) {\n    var _this = this;\n\n    this.handleUnsubscribe = function (observer) {\n      var index = _this.observers.indexOf(observer);\n\n      if (index !== -1) {\n        _this.observers.splice(index, 1);\n      }\n    };\n\n    this.handleResolverUpdate = function (listenId) {\n      if (listenId === _this.lastListenId) {\n        _this.lastListenId++;\n\n        if (!_this.isRefreshing) {\n          _this.refresh();\n        } else if (!_this.isRefreshScheduled) {\n          _this.isRefreshScheduled = true;\n        }\n      }\n    };\n\n    this.refresh = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var allChunks, i, _loop_1, this_1, state_1, chunksMapArray, i_1, item, lastChunk, listenId, handleUpdate, chunksMap, isSteady, i_2, _a, pathname, chunks, i_3, observer;\n\n        var _this = this;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              this.isRefreshScheduled = false;\n              this.isRefreshing = true;\n              allChunks = [];\n              i = 0;\n\n              _loop_1 = function () {\n                var item, pathname, result, chunks, focusIndex, focusChunk, patterns, key, j, expandedPatterns, k;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      item = this_1.mapItems[i];\n                      pathname = item.pathname;\n                      result = item.matcherIterator.next();\n\n                      if (!item.lastResult || result.value) {\n                        item.lastResult = result;\n                      }\n\n                      chunks = item.lastResult.value;\n                      item.chunksCache = chunks || [];\n                      focusIndex = chunks.findIndex(function (chunk) {\n                        return chunk.type === 'error' || chunk.url.href.length >= item.url.href.length && (chunk.type === 'mount' && item.lastMountPatterns !== chunk.patterns || chunk.type === 'redirect' && item.lastRedirectTo !== chunk.to);\n                      });\n                      _a.label = 1;\n\n                    case 1:\n                      if (!(focusIndex >= 0 && focusIndex < chunks.length)) return [3\n                      /*break*/\n                      , 6];\n                      focusChunk = chunks[focusIndex];\n                      focusIndex++; // If an item in the map cannot be found, throws an error, or is\n                      // no longer referenced by other items, then remove it from the\n                      // map.\n                      //\n                      // Note that later items in the map should always be \"from\" earlier\n                      // items, so if an earlier item is removed, its referenced items\n                      // will still be removed.\n\n                      if (focusChunk.type === 'error' || this_1.options.predicate && !this_1.options.predicate(focusChunk, chunks)) {\n                        this_1.removeFromQueue(item);\n                        return [2\n                        /*return*/\n                        , \"continue-items\"];\n                      }\n\n                      if (focusChunk.type === 'redirect') {\n                        item.lastRedirectTo = focusChunk.to;\n\n                        if (this_1.options.followRedirects) {\n                          this_1.addToQueue(focusChunk.to, item.depth + 1, item.walkedPatternLists, pathname, item.order);\n                        }\n                      }\n\n                      if (!(focusChunk.type === 'mount')) return [3\n                      /*break*/\n                      , 5];\n                      patterns = focusChunk.patterns;\n                      item.lastMountPatterns = patterns;\n                      key = patterns.slice(0).sort().join('\\n');\n                      if (!(patterns && !item.walkedPatternLists.has(key))) return [3\n                      /*break*/\n                      , 5];\n                      item.walkedPatternLists.add(key);\n                      j = 0;\n                      _a.label = 2;\n\n                    case 2:\n                      if (!(j < patterns.length)) return [3\n                      /*break*/\n                      , 5];\n                      return [4\n                      /*yield*/\n                      , this_1.expandPatterns(joinPaths(pathname, patterns[j]))];\n\n                    case 3:\n                      expandedPatterns = _a.sent();\n\n                      for (k = 0; k < expandedPatterns.length; k++) {\n                        this_1.addToQueue(expandedPatterns[k], item.depth + 1, item.walkedPatternLists, pathname, item.order.concat(j, k));\n                      }\n\n                      _a.label = 4;\n\n                    case 4:\n                      j++;\n                      return [3\n                      /*break*/\n                      , 2];\n\n                    case 5:\n                      return [3\n                      /*break*/\n                      , 1];\n\n                    case 6:\n                      if (chunks) {\n                        allChunks = allChunks.concat(chunks);\n                      } // Increment at the end of the loop in case the current item has\n                      // been removed, in which case the index won't change.\n\n\n                      i++;\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              };\n\n              this_1 = this;\n              _b.label = 1;\n\n            case 1:\n              if (!(this.mapItems && i < this.mapItems.length)) return [3\n              /*break*/\n              , 3];\n              return [5\n              /*yield**/\n              , _loop_1()];\n\n            case 2:\n              state_1 = _b.sent();\n\n              switch (state_1) {\n                case \"continue-items\":\n                  return [3\n                  /*break*/\n                  , 1];\n              }\n\n              return [3\n              /*break*/\n              , 1];\n\n            case 3:\n              // It's possible for the map to finish while waiting for expandPatterns to return.\n              if (!this.mapItems) {\n                return [2\n                /*return*/\n                ];\n              }\n\n              chunksMapArray = [];\n\n              for (i_1 = 0; i_1 < this.mapItems.length; i_1++) {\n                item = this.mapItems[i_1];\n                lastChunk = item.chunksCache[item.chunksCache.length - 1];\n\n                if (lastChunk.type !== 'mount' && lastChunk.type !== 'error' && (lastChunk.type === 'busy' || !this.options.predicate || this.options.predicate(lastChunk, item.chunksCache))) {\n                  chunksMapArray.push([joinPaths(item.pathname, '/'), item.chunksCache, item.order]);\n                }\n              }\n\n              listenId = ++this.lastListenId;\n\n              handleUpdate = function () {\n                return _this.handleResolverUpdate(listenId);\n              };\n\n              Promise.race(allChunks.filter(isBusy).map(pickChunkPromise)).then(handleUpdate, handleUpdate);\n              chunksMapArray.sort(function (itemX, itemY) {\n                var x = itemX[2];\n                var y = itemY[2];\n\n                if (x.length < y.length) {\n                  return -1;\n                }\n\n                if (x.length > y.length) {\n                  return 1;\n                }\n\n                for (var i_4 = 0; i_4 < x.length; i_4++) {\n                  if (x[i_4] < y[i_4]) {\n                    return -1;\n                  }\n\n                  if (x[i_4] > y[i_4]) {\n                    return 1;\n                  }\n                }\n\n                return 0;\n              });\n\n              if (this.isRefreshScheduled) {\n                this.refresh();\n              } else {\n                chunksMap = {};\n                isSteady = true;\n\n                for (i_2 = 0; i_2 < chunksMapArray.length; i_2++) {\n                  _a = __read(chunksMapArray[i_2], 2), pathname = _a[0], chunks = _a[1];\n\n                  if (chunks.some(function (chunk) {\n                    return chunk.type === 'busy';\n                  })) {\n                    isSteady = false;\n                  }\n\n                  chunksMap[modifyTrailingSlash(pathname, 'remove')] = chunks;\n                }\n\n                for (i_3 = 0; i_3 < this.observers.length; i_3++) {\n                  observer = this.observers[i_3];\n                  observer.next(chunksMap);\n\n                  if (isSteady && observer.complete) {\n                    observer.complete();\n                  }\n                }\n\n                if (isSteady) {\n                  delete this.rootContext;\n                  delete this.mapItems;\n                  delete this.router;\n                  delete this.observers;\n                }\n\n                this.isRefreshing = false;\n              }\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    this.observers = [];\n    this.lastListenId = 0;\n    this.mapItems = [];\n    this.router = router;\n    this.rootContext = rootContext;\n    this.matcherGeneratorFunction = matcherGeneratorClass;\n    this.rootMapping = rootMapping;\n    this.options = options;\n    this.seenPathnames = new Set();\n    var pathname = url.pathname; // A final '/' always indicates a Page or Redirect, and it\n    // doesn't really make sense to build a map of a single page/redirect.\n\n    if (pathname.substr(-1) === '/') {\n      pathname = pathname.substr(0, pathname.length - 1);\n    }\n\n    this.addToQueue(pathname, 0, new Set());\n  }\n\n  ChunksMapObservable.prototype.subscribe = function (onNextOrObserver, onError, onComplete) {\n    if (!this.observers) {\n      throw new Error(\"Can't subscribe to an already-complete RoutingObservable.\");\n    }\n\n    var observer = createOrPassthroughObserver(onNextOrObserver, onError, onComplete);\n    this.observers.push(observer);\n    var subscription = new SimpleSubscription(this.handleUnsubscribe, observer);\n\n    if (this.observers.length === 1) {\n      this.refresh();\n    }\n\n    return subscription;\n  };\n\n  ChunksMapObservable.prototype.expandPatterns = function (pattern) {\n    return __awaiter(this, void 0, void 0, function () {\n      var expandedPatterns;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.options.expandPattern) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.options.expandPattern(pattern, this.router)];\n\n          case 1:\n            expandedPatterns = _a.sent();\n\n            if (expandedPatterns) {\n              return [2\n              /*return*/\n              , expandedPatterns];\n            }\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            , [pattern].filter(function (pattern) {\n              return !/\\/:/.test(pattern);\n            })];\n        }\n      });\n    });\n  };\n\n  ChunksMapObservable.prototype.removeFromQueue = function (item) {\n    var i = this.mapItems.indexOf(item);\n\n    if (i !== -1) {\n      this.mapItems.splice(i, 1);\n    }\n  };\n\n  ChunksMapObservable.prototype.addToQueue = function (pathname, depth, walkedPatternLists, fromPathname, order) {\n    if (order === void 0) {\n      order = [0];\n    }\n\n    if (this.seenPathnames.has(pathname)) {\n      return;\n    }\n\n    if (!this.options.maxDepth || depth <= this.options.maxDepth) {\n      this.seenPathnames.add(pathname);\n      var url = createURLDescriptor(pathname, {\n        removeHash: true\n      });\n      var request = {\n        body: null,\n        context: this.rootContext,\n        headers: this.options.headers || {},\n        method: this.options.method || 'HEAD',\n        params: {},\n        hostname: this.options.hostname || '',\n        mountpath: '',\n        query: url.query,\n        search: url.search,\n        hash: url.hash,\n        path: url.pathname,\n        url: url.pathname + url.search,\n        originalUrl: url.href,\n        state: {}\n      };\n      var matchRequest = matchAgainstPathname(request, this.rootMapping);\n\n      if (matchRequest) {\n        this.mapItems.push({\n          url: url,\n          fromPathname: fromPathname,\n          depth: depth,\n          pathname: pathname,\n          order: order,\n          walkedPatternLists: new Set(walkedPatternLists),\n          matcherIterator: this.matcherGeneratorFunction(matchRequest)\n        });\n      }\n    }\n  };\n\n  return ChunksMapObservable;\n}();\n\nexport { ChunksMapObservable };\n\nfunction isBusy(chunk) {\n  return chunk.type === 'busy';\n}\n\nfunction pickChunkPromise(chunk) {\n  return chunk.promise;\n}","map":{"version":3,"sources":["../../src/ChunksMapObservable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { createURLDescriptor, joinPaths, modifyTrailingSlash, } from './URLTools';\nimport { SimpleSubscription, createOrPassthroughObserver, } from './Observable';\nimport { matchAgainstPathname } from './Mapping';\nvar ChunksMapObservable = /** @class */ (function () {\n    function ChunksMapObservable(url, rootContext, matcherGeneratorClass, rootMapping, router, options) {\n        var _this = this;\n        this.handleUnsubscribe = function (observer) {\n            var index = _this.observers.indexOf(observer);\n            if (index !== -1) {\n                _this.observers.splice(index, 1);\n            }\n        };\n        this.handleResolverUpdate = function (listenId) {\n            if (listenId === _this.lastListenId) {\n                _this.lastListenId++;\n                if (!_this.isRefreshing) {\n                    _this.refresh();\n                }\n                else if (!_this.isRefreshScheduled) {\n                    _this.isRefreshScheduled = true;\n                }\n            }\n        };\n        this.refresh = function () { return __awaiter(_this, void 0, void 0, function () {\n            var allChunks, i, _loop_1, this_1, state_1, chunksMapArray, i_1, item, lastChunk, listenId, handleUpdate, chunksMap, isSteady, i_2, _a, pathname, chunks, i_3, observer;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        this.isRefreshScheduled = false;\n                        this.isRefreshing = true;\n                        allChunks = [];\n                        i = 0;\n                        _loop_1 = function () {\n                            var item, pathname, result, chunks, focusIndex, focusChunk, patterns, key, j, expandedPatterns, k;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        item = this_1.mapItems[i];\n                                        pathname = item.pathname;\n                                        result = item.matcherIterator.next();\n                                        if (!item.lastResult || result.value) {\n                                            item.lastResult = result;\n                                        }\n                                        chunks = item.lastResult.value;\n                                        item.chunksCache = chunks || [];\n                                        focusIndex = chunks.findIndex(function (chunk) {\n                                            return chunk.type === 'error' ||\n                                                (chunk.url.href.length >= item.url.href.length &&\n                                                    ((chunk.type === 'mount' &&\n                                                        item.lastMountPatterns !== chunk.patterns) ||\n                                                        (chunk.type === 'redirect' && item.lastRedirectTo !== chunk.to)));\n                                        });\n                                        _a.label = 1;\n                                    case 1:\n                                        if (!(focusIndex >= 0 && focusIndex < chunks.length)) return [3 /*break*/, 6];\n                                        focusChunk = chunks[focusIndex];\n                                        focusIndex++;\n                                        // If an item in the map cannot be found, throws an error, or is\n                                        // no longer referenced by other items, then remove it from the\n                                        // map.\n                                        //\n                                        // Note that later items in the map should always be \"from\" earlier\n                                        // items, so if an earlier item is removed, its referenced items\n                                        // will still be removed.\n                                        if (focusChunk.type === 'error' ||\n                                            (this_1.options.predicate &&\n                                                !this_1.options.predicate(focusChunk, chunks))) {\n                                            this_1.removeFromQueue(item);\n                                            return [2 /*return*/, \"continue-items\"];\n                                        }\n                                        if (focusChunk.type === 'redirect') {\n                                            item.lastRedirectTo = focusChunk.to;\n                                            if (this_1.options.followRedirects) {\n                                                this_1.addToQueue(focusChunk.to, item.depth + 1, item.walkedPatternLists, pathname, item.order);\n                                            }\n                                        }\n                                        if (!(focusChunk.type === 'mount')) return [3 /*break*/, 5];\n                                        patterns = focusChunk.patterns;\n                                        item.lastMountPatterns = patterns;\n                                        key = patterns\n                                            .slice(0)\n                                            .sort()\n                                            .join('\\n');\n                                        if (!(patterns && !item.walkedPatternLists.has(key))) return [3 /*break*/, 5];\n                                        item.walkedPatternLists.add(key);\n                                        j = 0;\n                                        _a.label = 2;\n                                    case 2:\n                                        if (!(j < patterns.length)) return [3 /*break*/, 5];\n                                        return [4 /*yield*/, this_1.expandPatterns(joinPaths(pathname, patterns[j]))];\n                                    case 3:\n                                        expandedPatterns = _a.sent();\n                                        for (k = 0; k < expandedPatterns.length; k++) {\n                                            this_1.addToQueue(expandedPatterns[k], item.depth + 1, item.walkedPatternLists, pathname, item.order.concat(j, k));\n                                        }\n                                        _a.label = 4;\n                                    case 4:\n                                        j++;\n                                        return [3 /*break*/, 2];\n                                    case 5: return [3 /*break*/, 1];\n                                    case 6:\n                                        if (chunks) {\n                                            allChunks = allChunks.concat(chunks);\n                                        }\n                                        // Increment at the end of the loop in case the current item has\n                                        // been removed, in which case the index won't change.\n                                        i++;\n                                        return [2 /*return*/];\n                                }\n                            });\n                        };\n                        this_1 = this;\n                        _b.label = 1;\n                    case 1:\n                        if (!(this.mapItems && i < this.mapItems.length)) return [3 /*break*/, 3];\n                        return [5 /*yield**/, _loop_1()];\n                    case 2:\n                        state_1 = _b.sent();\n                        switch (state_1) {\n                            case \"continue-items\": return [3 /*break*/, 1];\n                        }\n                        return [3 /*break*/, 1];\n                    case 3:\n                        // It's possible for the map to finish while waiting for expandPatterns to return.\n                        if (!this.mapItems) {\n                            return [2 /*return*/];\n                        }\n                        chunksMapArray = [];\n                        for (i_1 = 0; i_1 < this.mapItems.length; i_1++) {\n                            item = this.mapItems[i_1];\n                            lastChunk = item.chunksCache[item.chunksCache.length - 1];\n                            if (lastChunk.type !== 'mount' &&\n                                lastChunk.type !== 'error' &&\n                                (lastChunk.type === 'busy' ||\n                                    !this.options.predicate ||\n                                    this.options.predicate(lastChunk, item.chunksCache))) {\n                                chunksMapArray.push([\n                                    joinPaths(item.pathname, '/'),\n                                    item.chunksCache,\n                                    item.order,\n                                ]);\n                            }\n                        }\n                        listenId = ++this.lastListenId;\n                        handleUpdate = function () { return _this.handleResolverUpdate(listenId); };\n                        Promise.race(allChunks.filter(isBusy).map(pickChunkPromise)).then(handleUpdate, handleUpdate);\n                        chunksMapArray.sort(function (itemX, itemY) {\n                            var x = itemX[2];\n                            var y = itemY[2];\n                            if (x.length < y.length) {\n                                return -1;\n                            }\n                            if (x.length > y.length) {\n                                return 1;\n                            }\n                            for (var i_4 = 0; i_4 < x.length; i_4++) {\n                                if (x[i_4] < y[i_4]) {\n                                    return -1;\n                                }\n                                if (x[i_4] > y[i_4]) {\n                                    return 1;\n                                }\n                            }\n                            return 0;\n                        });\n                        if (this.isRefreshScheduled) {\n                            this.refresh();\n                        }\n                        else {\n                            chunksMap = {};\n                            isSteady = true;\n                            for (i_2 = 0; i_2 < chunksMapArray.length; i_2++) {\n                                _a = __read(chunksMapArray[i_2], 2), pathname = _a[0], chunks = _a[1];\n                                if (chunks.some(function (chunk) { return chunk.type === 'busy'; })) {\n                                    isSteady = false;\n                                }\n                                chunksMap[modifyTrailingSlash(pathname, 'remove')] = chunks;\n                            }\n                            for (i_3 = 0; i_3 < this.observers.length; i_3++) {\n                                observer = this.observers[i_3];\n                                observer.next(chunksMap);\n                                if (isSteady && observer.complete) {\n                                    observer.complete();\n                                }\n                            }\n                            if (isSteady) {\n                                delete this.rootContext;\n                                delete this.mapItems;\n                                delete this.router;\n                                delete this.observers;\n                            }\n                            this.isRefreshing = false;\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        this.observers = [];\n        this.lastListenId = 0;\n        this.mapItems = [];\n        this.router = router;\n        this.rootContext = rootContext;\n        this.matcherGeneratorFunction = matcherGeneratorClass;\n        this.rootMapping = rootMapping;\n        this.options = options;\n        this.seenPathnames = new Set();\n        var pathname = url.pathname;\n        // A final '/' always indicates a Page or Redirect, and it\n        // doesn't really make sense to build a map of a single page/redirect.\n        if (pathname.substr(-1) === '/') {\n            pathname = pathname.substr(0, pathname.length - 1);\n        }\n        this.addToQueue(pathname, 0, new Set());\n    }\n    ChunksMapObservable.prototype.subscribe = function (onNextOrObserver, onError, onComplete) {\n        if (!this.observers) {\n            throw new Error(\"Can't subscribe to an already-complete RoutingObservable.\");\n        }\n        var observer = createOrPassthroughObserver(onNextOrObserver, onError, onComplete);\n        this.observers.push(observer);\n        var subscription = new SimpleSubscription(this.handleUnsubscribe, observer);\n        if (this.observers.length === 1) {\n            this.refresh();\n        }\n        return subscription;\n    };\n    ChunksMapObservable.prototype.expandPatterns = function (pattern) {\n        return __awaiter(this, void 0, void 0, function () {\n            var expandedPatterns;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.options.expandPattern) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.options.expandPattern(pattern, this.router)];\n                    case 1:\n                        expandedPatterns = _a.sent();\n                        if (expandedPatterns) {\n                            return [2 /*return*/, expandedPatterns];\n                        }\n                        _a.label = 2;\n                    case 2: return [2 /*return*/, [pattern].filter(function (pattern) { return !/\\/:/.test(pattern); })];\n                }\n            });\n        });\n    };\n    ChunksMapObservable.prototype.removeFromQueue = function (item) {\n        var i = this.mapItems.indexOf(item);\n        if (i !== -1) {\n            this.mapItems.splice(i, 1);\n        }\n    };\n    ChunksMapObservable.prototype.addToQueue = function (pathname, depth, walkedPatternLists, fromPathname, order) {\n        if (order === void 0) { order = [0]; }\n        if (this.seenPathnames.has(pathname)) {\n            return;\n        }\n        if (!this.options.maxDepth || depth <= this.options.maxDepth) {\n            this.seenPathnames.add(pathname);\n            var url = createURLDescriptor(pathname, {\n                removeHash: true,\n            });\n            var request = {\n                body: null,\n                context: this.rootContext,\n                headers: this.options.headers || {},\n                method: this.options.method || 'HEAD',\n                params: {},\n                hostname: this.options.hostname || '',\n                mountpath: '',\n                query: url.query,\n                search: url.search,\n                hash: url.hash,\n                path: url.pathname,\n                url: url.pathname + url.search,\n                originalUrl: url.href,\n                state: {},\n            };\n            var matchRequest = matchAgainstPathname(request, this.rootMapping);\n            if (matchRequest) {\n                this.mapItems.push({\n                    url: url,\n                    fromPathname: fromPathname,\n                    depth: depth,\n                    pathname: pathname,\n                    order: order,\n                    walkedPatternLists: new Set(walkedPatternLists),\n                    matcherIterator: this.matcherGeneratorFunction(matchRequest),\n                });\n            }\n        }\n    };\n    return ChunksMapObservable;\n}());\nexport { ChunksMapObservable };\nfunction isBusy(chunk) {\n    return chunk.type === 'busy';\n}\nfunction pickChunkPromise(chunk) {\n    return chunk.promise;\n}\n//# sourceMappingURL=ChunksMapObservable.js.map"]},"metadata":{},"sourceType":"module"}