{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nvar parsePattern = /((((\\/?(?:[^\\/\\?#]+\\/+)*)([^\\?#]*)))?(\\?[^#]+)?)(#.*)?/;\nexport function createURLDescriptor(urlOrDescriptor, _a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.removeHash,\n      removeHash = _c === void 0 ? false : _c,\n      _d = _b.trailingSlash,\n      trailingSlash = _d === void 0 ? null : _d;\n\n  var hostname;\n  var pathname;\n  var query;\n  var search;\n  var hash;\n\n  if (typeof urlOrDescriptor === 'string') {\n    var matches = parsePattern.exec(urlOrDescriptor);\n\n    if (!matches) {\n      throw new Error(\"Couldn't parse the provided URL.\");\n    }\n\n    hostname = '';\n    pathname = modifyTrailingSlash(matches[2] || '', trailingSlash);\n    search = matches[6] || '';\n    query = parseQuery(search);\n    hash = matches[7] || '';\n  } else {\n    hostname = urlOrDescriptor.hostname || '';\n    pathname = modifyTrailingSlash(urlOrDescriptor.pathname || '', trailingSlash);\n    query = urlOrDescriptor.query || (urlOrDescriptor.search ? parseQuery(urlOrDescriptor.search) : {});\n    search = urlOrDescriptor.search || stringifyQuery(query);\n    hash = urlOrDescriptor.hash || '';\n  }\n\n  return {\n    hostname: hostname,\n    pathname: pathname,\n    query: query,\n    search: search,\n    hash: removeHash ? '' : hash,\n    href: pathname + search + hash\n  };\n}\nexport function parseQuery(queryString, leadingCharacter) {\n  if (leadingCharacter === void 0) {\n    leadingCharacter = '?';\n  }\n\n  if (!queryString || queryString[0] != leadingCharacter) {\n    return {};\n  }\n\n  var query = {};\n  var queryParts = queryString.slice(1).split('&');\n\n  for (var i = 0, len = queryParts.length; i < len; i++) {\n    var x = queryParts[i].split('=');\n    query[x[0]] = x[1] ? decodeURIComponent(x[1]) : '';\n  }\n\n  return query;\n}\nexport function stringifyQuery(query, leadingCharacter) {\n  if (leadingCharacter === void 0) {\n    leadingCharacter = '?';\n  }\n\n  var keys = Object.keys(query);\n\n  if (keys.length === 0) {\n    return '';\n  }\n\n  var parts = [];\n\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = String(query[key]);\n    parts.push(value === '' ? key : key + '=' + encodeURIComponent(value));\n  }\n\n  return leadingCharacter + parts.join('&');\n}\n\nfunction splitPath(path) {\n  if (path === '') {\n    return [];\n  }\n\n  return path.split('/');\n} // users/789/, profile      => users/789/profile/\n// /users/123, .           => /users/123\n// /users/123, ..          => /users\n// /users/123, ../..       => /\n// /a/b/c/d,   ../../one   => /a/b/one\n// /a/b/c/d,   .././one/    => /a/b/c/one/\n\n\nexport function joinPaths(base) {\n  var paths = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    paths[_i - 1] = arguments[_i];\n  }\n\n  var allSegments = splitPath(base);\n\n  for (var i = 0; i < paths.length; i++) {\n    allSegments.push.apply(allSegments, __spread(splitPath(paths[i])));\n  }\n\n  var pathSegments = [];\n  var lastSegmentIndex = allSegments.length - 1;\n\n  for (var i = 0; i <= lastSegmentIndex; i++) {\n    var segment = allSegments[i];\n\n    if (segment === \"..\") {\n      pathSegments.pop();\n    } // Allow empty segments on the first and final characters, so that leading\n    // and trailing slashes will not be affected.\n    else if (segment !== '.' && (segment !== '' || i === 0 || i === lastSegmentIndex)) {\n        pathSegments.push(segment);\n      }\n  }\n\n  return pathSegments.join('/');\n}\nexport function modifyTrailingSlash(pathname, action) {\n  var hasTrailingSlash = pathname.slice(-1) === '/';\n\n  if (action === 'add' && !hasTrailingSlash) {\n    return pathname + '/';\n  } else if (action === 'remove' && hasTrailingSlash && pathname.length > 1) {\n    return pathname.slice(0, -1);\n  }\n\n  return pathname;\n}","map":{"version":3,"sources":["../../src/URLTools.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nvar parsePattern = /((((\\/?(?:[^\\/\\?#]+\\/+)*)([^\\?#]*)))?(\\?[^#]+)?)(#.*)?/;\nexport function createURLDescriptor(urlOrDescriptor, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.removeHash, removeHash = _c === void 0 ? false : _c, _d = _b.trailingSlash, trailingSlash = _d === void 0 ? null : _d;\n    var hostname;\n    var pathname;\n    var query;\n    var search;\n    var hash;\n    if (typeof urlOrDescriptor === 'string') {\n        var matches = parsePattern.exec(urlOrDescriptor);\n        if (!matches) {\n            throw new Error(\"Couldn't parse the provided URL.\");\n        }\n        hostname = '';\n        pathname = modifyTrailingSlash(matches[2] || '', trailingSlash);\n        search = matches[6] || '';\n        query = parseQuery(search);\n        hash = matches[7] || '';\n    }\n    else {\n        hostname = urlOrDescriptor.hostname || '';\n        pathname = modifyTrailingSlash(urlOrDescriptor.pathname || '', trailingSlash);\n        query = urlOrDescriptor.query || (urlOrDescriptor.search ? parseQuery(urlOrDescriptor.search) : {});\n        search = urlOrDescriptor.search || stringifyQuery(query);\n        hash = urlOrDescriptor.hash || '';\n    }\n    return {\n        hostname: hostname,\n        pathname: pathname,\n        query: query,\n        search: search,\n        hash: removeHash ? '' : hash,\n        href: pathname + search + hash,\n    };\n}\nexport function parseQuery(queryString, leadingCharacter) {\n    if (leadingCharacter === void 0) { leadingCharacter = '?'; }\n    if (!queryString || queryString[0] != leadingCharacter) {\n        return {};\n    }\n    var query = {};\n    var queryParts = queryString.slice(1).split('&');\n    for (var i = 0, len = queryParts.length; i < len; i++) {\n        var x = queryParts[i].split('=');\n        query[x[0]] = x[1] ? decodeURIComponent(x[1]) : '';\n    }\n    return query;\n}\nexport function stringifyQuery(query, leadingCharacter) {\n    if (leadingCharacter === void 0) { leadingCharacter = '?'; }\n    var keys = Object.keys(query);\n    if (keys.length === 0) {\n        return '';\n    }\n    var parts = [];\n    for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i];\n        var value = String(query[key]);\n        parts.push(value === '' ? key : key + '=' + encodeURIComponent(value));\n    }\n    return leadingCharacter + parts.join('&');\n}\nfunction splitPath(path) {\n    if (path === '') {\n        return [];\n    }\n    return path.split('/');\n}\n// users/789/, profile      => users/789/profile/\n// /users/123, .           => /users/123\n// /users/123, ..          => /users\n// /users/123, ../..       => /\n// /a/b/c/d,   ../../one   => /a/b/one\n// /a/b/c/d,   .././one/    => /a/b/c/one/\nexport function joinPaths(base) {\n    var paths = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        paths[_i - 1] = arguments[_i];\n    }\n    var allSegments = splitPath(base);\n    for (var i = 0; i < paths.length; i++) {\n        allSegments.push.apply(allSegments, __spread(splitPath(paths[i])));\n    }\n    var pathSegments = [];\n    var lastSegmentIndex = allSegments.length - 1;\n    for (var i = 0; i <= lastSegmentIndex; i++) {\n        var segment = allSegments[i];\n        if (segment === \"..\") {\n            pathSegments.pop();\n        }\n        // Allow empty segments on the first and final characters, so that leading\n        // and trailing slashes will not be affected.\n        else if (segment !== '.' && (segment !== '' || i === 0 || i === lastSegmentIndex)) {\n            pathSegments.push(segment);\n        }\n    }\n    return pathSegments.join('/');\n}\nexport function modifyTrailingSlash(pathname, action) {\n    var hasTrailingSlash = pathname.slice(-1) === '/';\n    if (action === 'add' && !hasTrailingSlash) {\n        return pathname + '/';\n    }\n    else if (action === 'remove' && hasTrailingSlash && pathname.length > 1) {\n        return pathname.slice(0, -1);\n    }\n    return pathname;\n}\n//# sourceMappingURL=URLTools.js.map"]},"metadata":{},"sourceType":"module"}