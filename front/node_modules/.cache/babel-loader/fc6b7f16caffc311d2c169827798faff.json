{"ast":null,"code":"import { SimpleSubscription, createOrPassthroughObserver } from './Observable';\n\nvar ChunkListObservable =\n/** @class */\nfunction () {\n  function ChunkListObservable(url, request, matcherGenerator) {\n    var _this = this;\n\n    this.handleUnsubscribe = function (observer) {\n      var index = _this.observers.indexOf(observer);\n\n      if (index !== -1) {\n        _this.observers.splice(index, 1);\n      }\n    };\n\n    this.handleChange = function (listenId) {\n      if (listenId === _this.lastListenId) {\n        _this.lastListenId++;\n\n        _this.refresh();\n\n        var isDone = _this.result.done || _this.result.value.every(function (chunk) {\n          return chunk.type !== 'busy';\n        });\n\n        for (var i = 0; i < _this.observers.length; i++) {\n          var observer = _this.observers[i];\n          observer.next(_this.result.value);\n\n          if (isDone && observer.complete) {\n            observer.complete();\n          }\n        }\n\n        if (isDone) {\n          delete _this.matcherIterator;\n        }\n      }\n    };\n\n    this.refresh = function () {\n      var result = _this.matcherIterator.next();\n\n      if (result.value) {\n        _this.result = result;\n      }\n\n      if (!_this.result.done) {\n        var listenId_1 = ++_this.lastListenId;\n\n        var handleUpdate = function () {\n          return _this.handleChange(listenId_1);\n        };\n\n        Promise.race(_this.result.value.filter(isBusy).map(pickChunkPromise)).then(handleUpdate, handleUpdate);\n      }\n    };\n\n    this.url = url;\n    this.lastListenId = 0;\n    this.observers = [];\n    this.matcherIterator = matcherGenerator(request);\n  }\n\n  ChunkListObservable.prototype.subscribe = function (onNextOrObserver, onError, onComplete) {\n    if (!this.matcherIterator) {\n      throw new Error(\"Can't subscribe to an already-complete RoutingObservable.\");\n    }\n\n    var observer = createOrPassthroughObserver(onNextOrObserver, onError, onComplete);\n    this.observers.push(observer);\n    var subscription = new SimpleSubscription(this.handleUnsubscribe, observer);\n\n    if (this.observers.length === 1) {\n      this.handleChange(this.lastListenId);\n    }\n\n    return subscription;\n  };\n\n  return ChunkListObservable;\n}();\n\nexport { ChunkListObservable };\n\nfunction isBusy(chunk) {\n  return chunk.type === 'busy';\n}\n\nfunction pickChunkPromise(chunk) {\n  return chunk.promise;\n}","map":{"version":3,"sources":["../../src/ChunkListObservable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { SimpleSubscription, createOrPassthroughObserver } from './Observable';\nvar ChunkListObservable = /** @class */ (function () {\n    function ChunkListObservable(url, request, matcherGenerator) {\n        var _this = this;\n        this.handleUnsubscribe = function (observer) {\n            var index = _this.observers.indexOf(observer);\n            if (index !== -1) {\n                _this.observers.splice(index, 1);\n            }\n        };\n        this.handleChange = function (listenId) {\n            if (listenId === _this.lastListenId) {\n                _this.lastListenId++;\n                _this.refresh();\n                var isDone = _this.result.done || _this.result.value.every(function (chunk) { return chunk.type !== 'busy'; });\n                for (var i = 0; i < _this.observers.length; i++) {\n                    var observer = _this.observers[i];\n                    observer.next(_this.result.value);\n                    if (isDone && observer.complete) {\n                        observer.complete();\n                    }\n                }\n                if (isDone) {\n                    delete _this.matcherIterator;\n                }\n            }\n        };\n        this.refresh = function () {\n            var result = _this.matcherIterator.next();\n            if (result.value) {\n                _this.result = result;\n            }\n            if (!_this.result.done) {\n                var listenId_1 = ++_this.lastListenId;\n                var handleUpdate = function () { return _this.handleChange(listenId_1); };\n                Promise.race(_this.result.value\n                    .filter(isBusy)\n                    .map(pickChunkPromise)).then(handleUpdate, handleUpdate);\n            }\n        };\n        this.url = url;\n        this.lastListenId = 0;\n        this.observers = [];\n        this.matcherIterator = matcherGenerator(request);\n    }\n    ChunkListObservable.prototype.subscribe = function (onNextOrObserver, onError, onComplete) {\n        if (!this.matcherIterator) {\n            throw new Error(\"Can't subscribe to an already-complete RoutingObservable.\");\n        }\n        var observer = createOrPassthroughObserver(onNextOrObserver, onError, onComplete);\n        this.observers.push(observer);\n        var subscription = new SimpleSubscription(this.handleUnsubscribe, observer);\n        if (this.observers.length === 1) {\n            this.handleChange(this.lastListenId);\n        }\n        return subscription;\n    };\n    return ChunkListObservable;\n}());\nexport { ChunkListObservable };\nfunction isBusy(chunk) {\n    return chunk.type === 'busy';\n}\nfunction pickChunkPromise(chunk) {\n    return chunk.promise;\n}\n//# sourceMappingURL=ChunkListObservable.js.map"]},"metadata":{},"sourceType":"module"}